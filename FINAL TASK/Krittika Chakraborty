
// ================= MOTOR PINS =================
const int AIN1 = 5, AIN2 = 8, PWMA = 9;
const int BIN1 = 6, BIN2 = 7, PWMB = 10;
const int STBY = 4;

// ================= IR SENSORS =================
// [ JL ,  L ,  C ,  R , JR ]
const int juncLeft  = A5;
const int leftIR    = A3;
const int centerIR  = A2;
const int rightIR   = A1;
const int juncRight = A4;

// ================= SPEED & PID =================
int baseSpeed = 90;
int maxSpeed  = 200;

float Kp = 18;
float Kd = 8;

int error = 0;
int lastError = 0;
int PID_value;

// ================= SENSOR ARRAY =================
int s[5];   // digital: HIGH = black line

// ================= ULTRASONIC =================
const int trigPin = 11;
const int echoPin = 12;

// ================= GAS + FIRE =================
const int gasPin = A0;
const int fireSignalPin = A7;
int SMOKE_THRESHOLD = 450;
bool fireDetected = false;

// ================= GRAPH =================
#define NUM_NODES 9
#define INF 9999

int graph[NUM_NODES][NUM_NODES] = {
  {0,1,0,1,0,0,0,0,0},
  {1,0,1,0,0,0,0,0,0},
  {0,1,0,1,0,1,0,0,0},
  {1,0,1,0,1,0,1,0,0},
  {0,0,0,1,0,1,0,1,0},
  {0,0,1,0,1,0,0,0,1},
  {0,0,0,1,0,0,0,0,0},
  {0,0,0,0,1,0,0,0,1},
  {0,0,0,0,0,1,0,1,0}
};

// ================= DIRECTIONS =================
#define NORTH 0
#define EAST  1
#define SOUTH 2
#define WEST  3

int dir[NUM_NODES][NUM_NODES] = {
  {-1,NORTH,-1,EAST,-1,-1,-1,-1,-1},
  {SOUTH,-1,EAST,-1,-1,-1,-1,-1,-1},
  {-1,WEST,-1,SOUTH,-1,EAST,-1,-1,-1},
  {WEST,-1,NORTH,-1,EAST,-1,SOUTH,-1,-1},
  {-1,-1,-1,WEST,-1,NORTH,-1,EAST,-1},
  {-1,-1,WEST,-1,SOUTH,-1,-1,-1,EAST},
  {-1,-1,-1,NORTH,-1,-1,-1,-1,-1},
  {-1,-1,-1,-1,WEST,-1,-1,-1,NORTH},
  {-1,-1,-1,-1,-1,WEST,-1,SOUTH,-1}
};

int currentNode = 0;
int goalNode = 8;
int facing = NORTH;

int dist[NUM_NODES];
int prevNode[NUM_NODES];
bool visited[NUM_NODES];

// ================= SETUP =================
void setup() {
  Serial.begin(9600);

  pinMode(AIN1, OUTPUT); pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT); pinMode(BIN2, OUTPUT);
  pinMode(PWMA, OUTPUT); pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  pinMode(juncLeft, INPUT);
  pinMode(leftIR, INPUT);
  pinMode(centerIR, INPUT);
  pinMode(rightIR, INPUT);
  pinMode(juncRight, INPUT);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(fireSignalPin, INPUT);

  stopRobot();
}

// ================= MOTOR =================
void moveForward(int ls, int rs) {
  ls = constrain(ls, 0, maxSpeed);
  rs = constrain(rs, 0, maxSpeed);

  digitalWrite(AIN1, HIGH); digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, HIGH); digitalWrite(BIN2, LOW);

  analogWrite(PWMA, ls);
  analogWrite(PWMB, rs);
}

void stopRobot() {
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
}

// ================= SENSOR READ =================
void readSensors() {
  s[0] = digitalRead(juncLeft);
  s[1] = digitalRead(leftIR);
  s[2] = digitalRead(centerIR);
  s[3] = digitalRead(rightIR);
  s[4] = digitalRead(juncRight);
}

// ================= JUNCTION DETECT =================
bool isJunction() {
  int cnt = 0;
  for (int i = 0; i < 5; i++)
    if (s[i] == HIGH) cnt++;
  return (cnt >= 3);
}

// ================= HAZARD CHECK =================
bool pathBlocked() {
  return ultrasonicBlocked() || (fireDetected && smokeDetected());
}

// ================= PIVOT TURNS =================
void turnLeftTillLine() {
  digitalWrite(AIN1, LOW); digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, HIGH); digitalWrite(BIN2, LOW);

  while (true) {
    analogWrite(PWMA, 0);
    analogWrite(PWMB, baseSpeed + 40);
    readSensors();
    if (s[2] == LOW) break;
  }
  while (true) {
    analogWrite(PWMA, 0);
    analogWrite(PWMB, baseSpeed + 40);
    readSensors();
    if (s[2] == HIGH) break;
  }
}

void turnRightTillLine() {
  digitalWrite(AIN1, HIGH); digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, LOW);  digitalWrite(BIN2, LOW);

  while (true) {
    analogWrite(PWMA, baseSpeed + 40);
    analogWrite(PWMB, 0);
    readSensors();
    if (s[2] == LOW) break;
  }
  while (true) {
    analogWrite(PWMA, baseSpeed + 40);
    analogWrite(PWMB, 0);
    readSensors();
    if (s[2] == HIGH) break;
  }
}

// ================= RETURN TO CENTER =================
void returnToCenter() {
  moveForward(baseSpeed, baseSpeed);
  delay(80);
  stopRobot();

  while (true) {
    readSensors();
    if (s[2] == HIGH) break;
    moveForward(baseSpeed - 40, baseSpeed + 40);
  }
  stopRobot();
}

// ================= PID =================
void computePID() {
  if      (s[2] == HIGH) error = 0;
  else if (s[1] == HIGH) error = -1;
  else if (s[3] == HIGH) error = 1;
  else if (s[0] == HIGH) error = -2;
  else if (s[4] == HIGH) error = 2;
  else                   error = lastError;

  int d = error - lastError;
  lastError = error;

  PID_value = Kp * error + Kd * d;
  PID_value = constrain(PID_value, -80, 80);

  moveForward(baseSpeed + PID_value, baseSpeed - PID_value);
}

// ================= ULTRASONIC + FIRE =================
bool ultrasonicBlocked() {
  digitalWrite(trigPin, LOW); delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long d = pulseIn(echoPin, HIGH, 25000);
  if (d == 0) return false;
  return (d * 0.034 / 2 < 25);
}

bool smokeDetected() {
  return analogRead(gasPin) > SMOKE_THRESHOLD;
}

void updateFire() {
  fireDetected = digitalRead(fireSignalPin);
}

// ================= DIJKSTRA =================
void dijkstra(int start) {
  for (int i = 0; i < NUM_NODES; i++) {
    dist[i] = INF;
    visited[i] = false;
    prevNode[i] = -1;
  }
  dist[start] = 0;

  for (int i = 0; i < NUM_NODES; i++) {
    int u = -1, minD = INF;
    for (int j = 0; j < NUM_NODES; j++)
      if (!visited[j] && dist[j] < minD) {
        minD = dist[j];
        u = j;
      }
    if (u == -1) break;
    visited[u] = true;

    for (int v = 0; v < NUM_NODES; v++) {
      if (graph[u][v] && !visited[v] && dist[u] + 1 < dist[v]) {
        dist[v] = dist[u] + 1;
        prevNode[v] = u;
      }
    }
  }
}

int nextNode(int cur, int target) {
  int n = target;
  while (prevNode[n] != cur) {
    n = prevNode[n];
    if (n == -1) return -1;
  }
  return n;
}

// ================= JUNCTION HANDLER =================
int neighborInDirection(int node, int direction) {
  for (int i = 0; i < NUM_NODES; i++) {
    if (dir[node][i] == direction) {
      return i;
    }
  }
  return -1;   // no neighbor in that direction
}


void handleJunction() {
  stopRobot();
  delay(100);
  readSensors();

  bool leftPath    = (s[0] == HIGH || s[1] == HIGH);
  bool rightPath   = (s[4] == HIGH || s[3] == HIGH);
  bool forwardPath = (s[2] == HIGH);

  // ---- LEFT ----
  if (leftPath) {
    turnLeftTillLine();
    int nb = neighborInDirection(currentNode, (facing + 3) % 4);
    if (nb != -1 && pathBlocked()) {
      graph[currentNode][nb] = INF;
      graph[nb][currentNode] = INF;
    }
    returnToCenter();
  }

  // ---- RIGHT ----
  if (rightPath) {
    turnRightTillLine();
    int nb = neighborInDirection(currentNode, (facing + 1) % 4);
    if (nb != -1 && pathBlocked()) {
      graph[currentNode][nb] = INF;
      graph[nb][currentNode] = INF;
    }
    returnToCenter();
  }

  // ---- FORWARD ----
  if (forwardPath) {
    moveForward(baseSpeed, baseSpeed);
    delay(120);
    stopRobot();

    int nb = neighborInDirection(currentNode, facing);
    if (nb != -1 && pathBlocked()) {
      graph[currentNode][nb] = INF;
      graph[nb][currentNode] = INF;
    }
    returnToCenter();
  }

  // ---- DECIDE ----
  dijkstra(currentNode);
  int nxt = nextNode(currentNode, goalNode);
  if (nxt == -1) return;

  int desiredDir = dir[currentNode][nxt];

  if ((facing + 3) % 4 == desiredDir) turnLeftTillLine();
  else if ((facing + 1) % 4 == desiredDir) turnRightTillLine();

  facing = desiredDir;
  currentNode = nxt;
  lastError = 0;
}

// ================= LOOP =================
void loop() {
  updateFire();
  readSensors();

  if (isJunction()) {
    handleJunction();
    return;
  }

  if (s[1] == HIGH || s[2] == HIGH || s[3] == HIGH)
    computePID();
  else
    moveForward(baseSpeed - 50, baseSpeed + 50);
}
